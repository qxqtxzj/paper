\section{Related Work}
\noindent\textbf{Secure Cloud Storage Scheme.} Verifiable cloud storage services have been extensively studied, e.g., Proof of Data Possession (PDP) \cite{ateniese2007provable, ateniese2008scalable, erway2015dynamic,zhu2012cooperative} and Proof \red{of} Retrievability (POR) \cite{juels2007pors, bowers2009proofs, stefanov2012iris}. \blue{These schemes mainly focused on verifying the integrity of data stored in cloud services and enable restoring data blocks if they are corrupted.} However, they did not ensure \red{the} integrity of search results,  \red{which is the focus of VSSE}.
Authenticated data structures are used by a set of searching algorithms to verify the integrity of data blocks stored on an untrusted server. Several schemes have been proposed, e.g., Merkle Tree\cite{merkle1987digital}, authenticated hash table\cite{papamanthou2008authenticated}, and \red{authenticated} skip list\cite{pugh1990skip,goodrich2001implementation}. Merkle Tree is the most common structure used to verify data integrity. However, Merkle Tree cannot flexible support data update. %is not a balanced tree when new leaf nodes are added and the searching operations are efficient.
Moreover, the current verification scheme~\cite{kamara2011cs2} built upon Merkle Tree did not store keyword information in its intermediate node and thus it is not suitable for keyword related searches. An authenticated hash table enabled by the RSA accumulator can be used to verify search results as well. Unfortunate, it has low efficiency in searching and update operations. For example, the search delay of the authenticated hash table is in millisecond level, while that of \name is in microsecond level. Skip list used a multilayer linked list to improve its search efficiency, but the storage overhead is much higher than a tree structure if the keyword information is required in the search path.
 %First, Merkle Tree is not a balanced data structure, and search delay of the authenticated hash table leveraging the RSA accumulator is lower than Merkle Patricia Tree. The search delay of the authenticated hash table is in millisecond level, while that of the authenticated hash table is in microsecond level. Second, the current Merkle Tree scheme proposed by Kamara et al. [5] did not store additional information such as keyword in its intermediate node, so that it cannot enable empty result validation

\noindent\textbf{Verifiable Searchable Symmetric Encryption.} The CS2 scheme \cite{kamara2011cs2} enabled users to verify the search result by using dynamic search authenticators, but their scheme cannot prevent the attacks that the server maliciously replies an empty result.
Recently Kurosawa et al.~\cite{kurosawa2012uc,kurosawa2013update,ogataefficient} proposed a few verifiable SSE schemes. However, their schemes either have low search efficiency, or do not support verification upon file update.
Kurosawa et al. \cite{kurosawa2012uc} required linear search in SSE and did not support dynamic file update. Their extension \cite{kurosawa2013update} achieved dynamic updating but the search complexity was beyond linear time. Recently, Ogata et al. \cite{ogataefficient} presented a generic verifiable scheme. It transforms any SSE scheme to a \textit{no-dictionary} verifiable SSE scheme that did not require the users to keep the keyword set. However, it was still a static approach, which shared the similar shortcoming with~\cite{chai2012verifiable} \cite{cheng2015verifiable}.
%Also, schemes in~\cite{chai2012verifiable} \cite{cheng2015verifiable} only enabled static SSE.
Although the verifiable scheme proposed by Stefanov et al.\cite{stefanov2014practical} achieved verifiability by leveraging message authenticated code, it cannot easily detect the data integrity attacks when the server intentionally returned an empty result.
Bost et al. \cite{bost2016verifiable} presented a generic verifiable dynamic SSE scheme and combined it with the SSE scheme proposed by Stefanov et al. \cite{stefanov2014practical}.
Yet, their scheme required two round communications for result verification and did not enable verification in the setting of multiple users. Our \name scheme is a generic verifiable SSE scheme that can work with three-party model, which can be \red{more readily} deployed in practice. In particular, it enables search result verification under file update with only one round of communication.


\noindent\textbf{Verifiable Public Key Encryption with Keyword Search.} The first verifiable attribute-based keyword search (VABKS) was proposed by Zheng et al. \cite{zheng2014vabks}. Similar to the existing SSE schemes above, VABKS only focused on search based on static encrypted data. Liu et.al \cite{liu2014efficient} proposed a more efficient construction based on VABKS, and Sun et.al \cite{sun2015catch} also provided a verifiable scheme VCKS that support conjunctive keyword search. However, due to the limitations of asymmetric encryption schemes, both of the above schemes require an additional trusted authority.


\noindent\textbf{Multi-User Searchable Encryption.} A few of non-verifiable multi-user schemes have been proposed~\cite{curtmola2011searchable,yang2009multiuser,jarecki2013outsourced,sun2016efficient}. Curtmola et al.~\cite{curtmola2011searchable} first proposed a multi-user SSE scheme based on broadcast encryption. Yang et al.~\cite{yang2009multiuser} proposed a multi-user searchable encryption scheme by leveraging a bilinear map. However, the search delay of the scheme is proportional to the size of the database, which is not suitable for large-scale databases.
Jarecki et al. \cite{jarecki2013outsourced} designed a multi-user scheme by using Oblivious Cross-Tags (OXT) protocol. However, their scheme required frequent communication between data owners and the users, which incured unnecessary communication overheads. Recently, Sun et al.~\cite{sun2016efficient} proposed a non-interactive multi-user searchable encryption schemes that reduced the interactions between data owner and users. However, the scheme did not support search under data update.
