\chapter{绪论}
\label{cha:intro}
\section{研究背景及选题意义}
云存储使得用户可以随时随地地存取数据，并且极大地方便了用户之间的数据共享，降低了维护数据的成本~\cite{juels2007pors,ateniese2008scalable,kamara2011cs2,wang2011enabling,stefanov2012iris,kamara2013parallel,sun2015catch}。但与此同时，云存储也带来了许多安全性问题，例如，数据丢失，数据隐私泄露等等。总体来说，云存储带来的安全性问题可以分为以下两类：
\begin{itemize}
	\item 可用性问题。要求云服务器保证数据不丢失，用户可以将云端作为数据中枢进行数据备份和同步。目前，一般的云服务提供商都采用了多副本的方式保障数据的可用性，即将数据的多个副本分别写入其他的存储节点，当一个节点发生故障时，其他节点上的数据继续提供服务，同时通过其他节点中的数据副本，快速恢复故障节点上丢失的数据。目前，针对数据可用性的相关学术研究包括数据拥有证明 (Proof of Data Possession, PDP)\cite{ateniese2007provable, ateniese2008scalable, erway2015dynamic,zhu2012cooperative} 以及数据可恢复性证明 (Proof of Retrievability, PoR)\cite{juels2007pors, bowers2009proofs, stefanov2012iris}。
	\item 隐私性问题。要求云服务器保证数据的隐私并且不泄露数据。目前，云服务提供商一般采用数据加密方式对隐私数据进行保护，但数据加密往往会导致数据可用性的降低，例如数据失去可搜索性。因此加密搜索 (Searchable Encryption, SE) 应运而生。加密搜索技术主要分为两类，一是对称加密搜索 (Searchable Symmetric Encryption, SSE)\cite{song2000practical,curtmola2011searchable,kamara2012dynamic,cash2014dynamic,wang2016searchable}，二是公钥加密搜索 (Public Key Encryption with Keyword Search, PEKS)~\cite{boneh2004public}。
\end{itemize}
加密搜索的提出，使得用户可以在上传数据给云服务器之前，对其进行加密，并且使得云服务器可以在加密数据上进行搜索。从而既保证了数据隐私性，又保证了数据的可搜索性。目前，由于效率问题，应用较为广泛的为对称加密搜索技术。然而，大部分的对称加密搜索方案都基于服务器是诚实且好奇的假设~\cite{curtmola2011searchable, kamara2012dynamic, cash2014dynamic}，即服务器会遵循协议但是可以从用户的查询中推断相关信息。这种假设在实际应用场景中往往是不成立的。因为云服务器可能会因为外部攻击，内部配置错误，软件错误等等问题而导致其违反原有协议~\cite{sun2015catch,bost2016verifiable}。这种协议违反导致的最常见问题就是服务器返回的搜索结果不完整，例如，云服务器有可能为了节省计算开销和通信开销而返回少量搜索结果给用户，甚至有可能不返回搜索结果给用户。

为了解决该问题，可验证对称加密搜索技术也相应提出\cite{kamara2011cs2,kurosawa2012uc,chai2012verifiable,kurosawa2013update,stefanov2014practical,cheng2015verifiable,bost2016verifiable,ogataefficient}。可验证对称加密搜索技术允许用户对搜索结果进行验证，来检测服务器的不诚信行为，保障了加密搜索的正确性。然而，据我们所知，现有的可验证对称加密搜索方案都是不完善的。例如，有的方案~\cite{kurosawa2012uc,chai2012verifiable,cheng2015verifiable,ogataefficient}不支持数据更新，只能作用在静态数据库中，数据库若有变化则需要重建整个索引。有的方案~\cite{kamara2011cs2,kurosawa2013update,stefanov2014practical}无法防止服务器故意返回空结果来规避结果验证。特别需要说明的是，以上这些方案\cite{kamara2011cs2,kurosawa2013update,stefanov2014practical}在搜索关键字在数据库中不存在时，是不返回任何搜索结果的，这就导致了服务器可以对任意关键字返回空结果来规避结果验证，除非用户在本地保留数据库的所有关键字集合。另外，大部分的可验证对称加密搜索方案~\cite{kamara2011cs2,kurosawa2012uc,chai2012verifiable,kurosawa2013update,stefanov2014practical,
cheng2015verifiable,ogataefficient,bost2016verifiable}仅仅支持在单用户场景下工作，即用户自己写自己读的场景，而现实情况中，数据往往有共享需求，即一方写多方读。表格~\ref{tab:comparison}比较了现有的可验证对称加密搜索方案。


\begin{table*}[t]
  \begin{center}
  \caption{Comparison with existing typical verifiable SSE schemes.}
  \label{tab:comparison}
  %\begin{threeparttable}
  \begin{tabular}{|c|c|c|c|c|c|c|c}
    \hline
                                          &Dynamism     &Three-party$^1$    &Freshness Verify$^2$     &Integrity Verify$^3$    & Prove Efficiency$^4$        &Generality$^5$  \\
    \hline
    \hline
    KPR11~\cite{kamara2011cs2}            &\checkmark     &\texttimes     &\checkmark         &\texttimes                          &$O(|W|)$                      &\checkmark  \\
    \hline
    KO12~\cite{kurosawa2012uc}            &\texttimes     &\texttimes     &\text{-}           &\texttimes                          &$O(n)$                        &\texttimes\\
    \hline
    CG12~\cite{chai2012verifiable}        &\texttimes     &\texttimes     &\text{-}           &\checkmark                          &$O(log(|W|))$                 &\texttimes  \\
    \hline
    KO13~\cite{kurosawa2013update}        &\checkmark     &\texttimes     &\checkmark         &\texttimes                          &$O(n)$                        &\texttimes \\
    \hline
    SPS14~\cite{stefanov2014practical}    &\checkmark     &\texttimes     &\checkmark         &\texttimes                          &$min\{\alpha + log(N), r log^3(N)\}$                  &\texttimes \\
    \hline
    CYGZR15\cite{cheng2015verifiable}    &\texttimes     &\texttimes      &\text{-}         &\texttimes                            &$O(|W|)+O(r)$                 &\texttimes \\
    \hline
    BFP16~\cite{bost2016verifiable}       &\checkmark     &\texttimes     &\checkmark         &\checkmark                          &$O(r)$                        &\checkmark   \\
    \hline
    OK16~\cite{ogataefficient}            &\texttimes     &\texttimes     &\text{-}           &\checkmark                          &$O(r)$                        &\checkmark  \\
    \hline
    我们的方案                                 &\checkmark     &\checkmark     &\checkmark         &\checkmark                          &$O(log(|W|))$                 &\checkmark  \\
    \hline
  \end{tabular}\\
  \end{center}
  $^1$ Three-party means whether the scheme supports search result verification for an SSE scheme with three parties, i.e., data owners, servers, and users.\\
  $^2$ Note that, '\texttimes' represents the requirements which are not implemented, while '-' means the requirements which are not required. Specifically, the static verifiable SSE schemes do not have the problem of data freshness attacks, and thus the existing schemes~\cite{kurosawa2012uc,chai2012verifiable,cheng2015verifiable,ogataefficient} do not require data freshness verification.\\
  $^3$ We consider various data integrity attacks, especially the attacks that servers can intentionally returns an empty result to evade search result verification.\\
  $^4$ The prove efficiency refers to the cost of operations for search result verification. For some selected non-generic schemes~\cite{kurosawa2012uc,chai2012verifiable,kurosawa2013update,stefanov2014practical,cheng2015verifiable}, their prove efficiency is equivalent to their encrypted search efficiency. Here, $n$ indicates the number of total files, $|W|$ means the number of all keywords, $r$ means the number of files which contain the specific keyword, $\alpha$ means the number of times this keyword was historically added to the collection \cite{stefanov2014practical}, and $N$ means the total number of document and keyword pairs.\\
  $^5$ A generic VSSE scheme means that the verifiable design can provide result verification for any SSE schemes, while a non-generic scheme only works for a particular SSE construction.\\
\end{table*}




\section{本文的主要内容}

\section{本文的结构安排}
