\chapter{相关工作及问题定义}
\label{cha:related}

\section{研究现状}
\noindent\textbf{安全云存储方案：} 可验证的云存储服务已经被广泛的研究过，例如，数据拥有性证明 (Proof of Data Possession, PDP)~\cite{ateniese2007provable, ateniese2008scalable, erway2015dynamic,zhu2012cooperative}，数据可取回证明 (Proof of Retrievability, POR)~\cite{juels2007pors, bowers2009proofs, stefanov2012iris} 等等。这些方案主要侧重于云端存储数据的完整性验证，并支持数据块产生破坏时对其进行恢复。注意，这些方案与加密搜索场景下的结果验证是不同的，因为加密搜索的结果验证不仅需要验证某个文件本身的完整性，还需要验证整个搜索结果集合是否完整。而这些方案只能单纯验证数据块的完整性，不支持对搜索结果完整性的验证。
%These schemes mainly focused on verifying the integrity of data stored in cloud services and enable restoring data blocks if they are corrupted. However, they did not ensure the integrity of search results, which is the focus of VSSE.


%Note that, SSE result verification is different from verification used in proof of data possession (PDP) and proof retrievability (POR). An SSE scheme needs to not only verify the integrity of a particular file block but also the integrity of all the files that contain the specific keyword, which cannot be easily achieved by the authenticated data structures. We clarified these issues in Section 8.

\noindent\textbf{可验证数据结构：} 可验证数据结构 (Authenticated data structure) 被广泛应用于不可信的云存储环境中，用来验证数据块的完整性。典型的可验证数据结构包括：默克尔树 (Merkle Tree, MT)~\cite{merkle1987digital}, 可验证哈希表( Authenticated Hash Table, AHT)~\cite{papamanthou2008authenticated} 以及可验证跳表 (Authenticated Skip List)~\cite{pugh1990skip,goodrich2001implementation}。其中，默克尔树是最常见的用于验证数据完整性的数据结构，但是默克尔树对数据更新的支持不够灵活。采用默克尔树实现的可验证对称加密搜索方案~\cite{kamara2011cs2}没法在中间节点存储关键字信息，因此也不支持与关键字相关的搜索。可验证哈希表采用了RSA~\footnote{RSA为提出该算法的三个密码学家名字的首字母，分别为Ron Rivest, Adi Shamir, 和Leonard Adleman} 累加器 (RSA Accumulator) 方法来实现数据验证，但是它的搜索和更新性能都较低。具体而言，可验证哈希表的搜索与更新速度在毫秒级别，而我们采用的默克尔帕特里夏树的搜索更新速度在微秒级别。可验证跳表采用了类似多级链表的方式来实现，一定程度上提升了搜索性能，但如果它将关键字信息存储于搜索路径上，存储空间将比默克尔帕特里夏树大很多。

%Authenticated data structures are used by a set of searching algorithms to verify the integrity of data blocks stored on an untrusted server. Several schemes have been proposed, e.g., Merkle Tree\cite{merkle1987digital}, authenticated hash table\cite{papamanthou2008authenticated}, and authenticated skip list\cite{pugh1990skip,goodrich2001implementation}.

%Merkle Tree is the most common structure used to verify data integrity. However, Merkle Tree cannot flexible support data update.
%Moreover, the current verification scheme~\cite{kamara2011cs2} built upon Merkle Tree did not store keyword information in its intermediate node and thus it is not suitable for keyword related searches. An authenticated hash table enabled by the RSA accumulator can be used to verify search results as well. Unfortunate, it has low efficiency in searching and update operations. For example, the search delay of the authenticated hash table is in millisecond level, while that of %\name is in microsecond level. Skip list used a multilayer linked list to improve its search efficiency, but the storage overhead is much higher than a tree structure if the keyword information is required in the search path.



\noindent\textbf{可验证对称加密搜索方案：} 由Kamara等人提出的CS2方案~\cite{kamara2011cs2}通过使用默克尔树构建动态搜索鉴别符来支持用户对搜索结果的验证。具体的做法是，将加密关键字作为“键”，将该关键字对应的文件集合作为“值”，将其存储在默克尔树的叶子结点上。用户需要保留默克尔树的根哈希作为一个指纹信息，在进行结果验证时需要通过搜索关键字及其对应在默克尔树上的路径来重构出该根哈希，并与保留的根哈希进行比对，从而来进行结果验证。但是他们的方案无法检测服务器恶意返回空结果的情况。一个关键的原因是，当用户搜索的关键字不存在时，默克尔树上也不会存在该关键字对应的路径，因此服务器无法返回任何信息给用户。解决该问题的一个简单的方法是构建默克尔树时，将整个字典空间中所有可能的关键字集合都存储，但这将会导致大量的空间浪费。
近期，Kurosawa等人提出了一系列可验证对称加密搜索方案~\cite{kurosawa2012uc,kurosawa2013update,ogataefficient}。但是他们的方案要么效率很低，要么不支持用户数据动态更新。其中方案~\cite{kurosawa2012uc}需要线性搜索时间并且不支持数据动态更新，他们的扩展方案~\cite{kurosawa2013update}支持了用户数据更新，但是搜索复杂度超过了线性时间。近期，Ogata等人也提出了一个通用的可验证对称加密搜索框架~\cite{ogataefficient},它也可以为任何对称加密搜索方案提供结果验证服务，并且不需要用户自己在本地维护一个关键字集合，但是他们的方案仍然是一个静态的方案，即不支持用户数据更新。方案~\cite{chai2012verifiable} \cite{cheng2015verifiable}也同样只是静态方案。由Stefanov等人提出的方案~\cite{stefanov2014practical}采用了消息验证码 (Message Authenticated Code, MAC)机制来实现了结果验证，但是他们的方案没法防御服务器故意返回空结果来规避结果验证的情况。Bost等人提出的方案~\cite{bost2016verifiable}是目前为止最完善的可验证对称加密搜索方案，但他们的方案在搜索时需要和服务器有两轮通信才能进行验证，无法并行进行验证，并且他们的方案同样也不支持多用户情况下的验证。


Kurosawa et al. [8] leveraged Message Authenticated Code (MAC) to ensure data integrity and utilizes RSA accumulator to ensure data freshness during data updates. However, the existing study [12] showed that users in [8] required maintaining all keywords in the datasets to detect cheating of servers. It introduces significant overhead for users to maintain a large set of keywords. Therefore, paper [12] proposed a no-dictionary VSSE scheme, which means users do not need to keep the keywords set as a dictionary. However, their scheme only works in the static setting and does not consider data update scenarios.
Stefanov et al. [9] also used MAC and timestamp to ensure data integrity and freshness. However, they were still unable verify an empty search result unless the data owner maintained all keywords locally.
In summary, verification on the three-party model (across multiple users) should allow users to verify an empty result in addition to verification of integrity and freshness of search results. Meanwhile, it is desirable that users do not need to maintain a large set of keywords locally for the verification. We clarified this issue in Section 1.

\noindent\textbf{可验证公钥加密搜索方案}第一个可验证的非对称加密搜索方案[18]由Zheng等人提出，他们的方案采用了基于属性的关键字（Attribute-based keyword，ABK），但是他们的方案也只适用于数据库静态的情况。基于他们的工作，Liu等人又提出了一个更高效的可验证非对称加密搜索方案[19]，然而，由于非对称加密本身的限制，他们的方案必不可少地需要引入一个可信第三方。The first verifiable attribute-based keyword search (VABKS) was proposed by Zheng et al. \cite{zheng2014vabks}. Similar to the existing SSE schemes above, VABKS only focused on search based on static encrypted data. Liu et.al \cite{liu2014efficient} proposed a more efficient construction based on VABKS, and Sun et.al \cite{sun2015catch} also provided a verifiable scheme VCKS that support conjunctive keyword search. However, due to the limitations of asymmetric encryption schemes, both of the above schemes require an additional trusted authority.

\noindent\textbf{多用户加密搜索方案} 	Curtmola等人在2006年即提出了一个基于广播加密的多用户加密搜索方案[2]，该方案允许数据拥有者将数据分享给其他用户，并且数据拥有者具有对用户的访问控制权限，可以随时撤销或者新增用户。Jerecki等人随后又提出了一个基于Oblivious Cross Tag的加密搜索方案[21]，然而该方案需要数据拥有者和数据用户频繁的交互。A few of non-verifiable multi-user schemes have been proposed~\cite{curtmola2011searchable,yang2009multiuser,jarecki2013outsourced,sun2016efficient}. Curtmola et al.~\cite{curtmola2011searchable} first proposed a multi-user SSE scheme based on broadcast encryption. Yang et al.~\cite{yang2009multiuser} proposed a multi-user searchable encryption scheme by leveraging a bilinear map. However, the search delay of the scheme is proportional to the size of the database, which is not suitable for large-scale databases.
Jarecki et al. \cite{jarecki2013outsourced} designed a multi-user scheme by using Oblivious Cross-Tags (OXT) protocol. However, their scheme required frequent communication between data owners and the users, which incured unnecessary communication overheads. Recently, Sun et al.~\cite{sun2016efficient} proposed a non-interactive multi-user searchable encryption schemes that reduced the interactions between data owner and users. However, the scheme did not support search under data update.

	【multi-user】Thanks for the comments. We emphasized that we did not aim to design a multi-user scheme for access control of search. Instead, our design aimed to provide results verification across multiple users. To the best of our knowledge, the existing VSSE schemes were all based on the two-party model and there did not exist a verifiable solution on the three-party model [11]. Specifically, verification on the three-party model faced more challenges than the two-party model. For example, when data was shared among users, a malicious server can easily mounted a data freshness attack because the users cannot detect a data update unless the data owner sent the update information to them. However, such an approach incurred a significant communication cost. In this paper, we proposed a VSSE scheme that is able to not only detect data integrity attack (especially when the server deliberately returns an empty result) but also capture data freshness attack by using a timestamp chain based mechanism. In our scheme, data owner only needed to send update information to the server, and data users can verify the search results by leveraging the information retrieved from the server without interacting with the data owner.


\noindent\textbf{总结}
	综上所述，现有的可验证加密搜索方案都不能满足多用户场景下的安全性保证，并且现有的方案无法完善地解决重放攻击和数据完整性攻击。这需要我们设计合理的机制来防御多用户场景下重放攻击，并且需要我们利用新型的数据结构来完善对数据完整性攻击的防御，尤其是防御服务器返回空结果来规避结果验证的情况。






\section{先验知识}

\noindent\textbf{Incremental Hash.} Incremental hash was proposed by Bellare et al.~\cite{bellare1994incremental} and was used by existing SSE schemes, e.g., CS2~\cite{kamara2011cs2}. An incremental hash function is a collision-resistant function $IH: \{0,1\}^* \rightarrow \{0,1\}^l$, with which the addition or the subtraction operation of two random strings on the $IH$ does not produce a collision. For example, assuming $F$ is a file collection that contains the keyword $k$. After a new file $f$ is inserted to $F$, the file collection becomes $F'$ (i.e., $F+f$), which means the new file $f$ is a slight change according to $F$.  Therefore, an incremental hash function can be used to quickly compute the corresponding collision-resist hash value after a file change. More detailed descriptions can be found in~\cite{kamara2011cs2}.


【IH】Thank the reviewer for pointing out this issue. We reviewed the incremental hash in Section 2. An incremental hash function is a collision-resistant function, which was first proposed by Bellare et al. [22]. We revised the description of the incremental hash in Section 2.
In our scheme, if a file collection of a data owner is changed, the data owner uses the incremental hash function to quickly calculate a collision-resistance hash value of the changed data, which achieves high efficiency in computing hash values. Another advantage is that, when a file is added or deleted, a collision-resistance hash value ensures the security of our scheme during update.

\noindent\textbf{Merkle Patricia Tree.} The Merkle Patricia Tree (MPT) is first proposed in Ethereum~ \cite{wood2014ethereum, merkle_patricia_tree}, which combines the Trie Tree and the Merkle Tree for data update efficiency. There are three kinds of nodes in an MPT to achieve the goal. Leaf Nodes(LN) represents [key,value] pairs. Extension Nodes(EN) represent [key,value] pairs where keys are the public prefixes and their values are the hashes of the next nodes. The Branch Nodes (BN) are used to store possible branches when the prefixes of the keywords differ, which is presented with 17 elements. Among the 17 elements, the first 16 elements represent the 16 possible hex characters in a key and the last element stores a value if a key in a [key,value] pair matches the node. Fig.~\ref{fig:mpt_detail} shows insertion operations of a Merkle Patricia Tree (MPT) with the following four cases. First, to insert a [key,value] pair into a branch node, there are two possible cases. If the current key is empty, we can directly insert the value into the 17th bucket of the branch node. Otherwise, the unmatched key and value will be stored in a leaf node. Second, if we want to insert a [key,value] pair into a leaf node, there are also two possible cases. If the current key matches, we should modify the value of the leaf node directly. Otherwise, we should find the common prefix as the key of a newly created extension node. Meanwhile, we create a new branch node, and the original leaf node and the inserting [key,value] pair will be inserted as child node of the branch node.
Note that, each node of the MPT is represented by its hash and is encoded using Recursive Length Prefix (RLP) code that is mainly used to encode arbitrarily binary data~\cite{RLP_code}, which ensures the cryptographically security of the search operations. The root hash in MPT becomes a fingerprint of the entire tree and is computed based on all hashes of nodes below. Therefore, any modification in a node would incur recomputation of the root hash. Note that, the MPT is fully deterministic, meaning that an MPT with the same [key,value] pairs is exactly the same regardless of the order of insertion, which is different from the Merkle Tree.


\noindent\textbf{Secure Searchable Encryption.} Searchable Encryption was first proposed by Song et al. \cite{song2000practical}, their solution allows a user to outsource its encrypted data to cloud services, and meanwhile retaining the ability to search over it. Normally, searchable encryption has been divided into two categories, i.e.,  Searchable Symmetric Encryption(SSE) and Public Key Encryption with keyword search(PKE). The most classical SSE scheme was proposed by Curtmola et al. in~\cite{curtmola2011searchable}. They defined  privacy against passive adversaries (i.e., honest but curious servers) and developed their scheme by using an inverted index. There exist various SSE schemes with different secure searching functionalities. For example, dynamic SSE schemes~\cite{kamara2012dynamic,cash2014dynamic,stefanov2014practical} allow a user to update his dataset and ranked keyword search scheme~\cite{wang2010secure} that allow a user to retrieve  ranked search results from the server. The most famous PKE scheme was proposed by Boneh et al.~\cite{boneh2004public} with the bilinear map. Normally, the efficiency of the PKE schemes are much lower than the SSE schemes.

【SSE】Thanks for the suggestions. We explained the secure searchable encryption schemes in Section 2. Searchable encryption allows the server to perform search operations without seeing plaintext data. It empowers the server an ability to search over ciphertext and ensures the security of data on the server. In this revised manuscript, we discussed the existing categories of searchable encryption in Section 2.

\section{问题定义}


\subsection{Threat Model}
We assume that the data owner is trusted and the data users authorized by the data owner are also trusted\footnote{Please refer to Section \ref{Sec:Discussion} for details on how we can enforce such assumption in practice with multi-user access control techniques.}.
We consider cloud services performing searchable symmetric encryption (SSE) to be untrusted, which means 1) cloud services intends to derive some sensitive information from the encrypted data and the queries; 2) cloud services may deviate from the prescribed protocols and mount a data freshness attack or a data integrity attack to save its computation or communication cost. The definitions of the data freshness attack and the data integrity attack are presented as follow:

\begin{definition}[\textbf{Data Freshness Attacks}]\label{def:freshness}
    {\itshape
      A data freshness attack in SSE is that a malicious server (or an attacker) attempts to return the historical version of the search result, not the most recently updated version. Formally, let $\Delta_{n-1} = \{\delta_1,\delta_2,\cdots,\delta_{n-1}\}$ denote the historical version of the dataset and $\delta_n$ is the latest version. However, the search result returned by the server is retrieved from $\delta_i$ where $1 \le i \le n-1$.
    }
\end{definition}

\begin{definition}[\textbf{Data Integrity Attacks}]\label{def:integrity}
    {\itshape
      A data integrity attack in SSE is that a malicious server (or an attacker) attempts to tamper with the search result to prevent authenticated users from accessing the complete and correct search result. Formally, let $\tau$ be the search token of the SSE scheme, and $\delta_i$ be the dataset, where $1 \le i \le n$, the corresponding search result should be $\mathcal{F}(\delta_i, \tau)$, but the result returned by the server is $\mathcal{G}(\delta_i, \tau)$, where $\mathcal{G}(\delta_i, \tau) \neq \mathcal{F}(\delta_i, \tau)$.
    }
\end{definition}



\subsection{Design Goal}
  In this paper, we aim to design a generic verifiable SSE scheme that enables verifiable searches on the three-party model. In particular, the scheme should satisfy the following privacy and efficiency requirements:


  \begin{enumerate}
    \item \textbf{Confidentiality:} The confidentiality of data and keywords is the most important privacy requirements in SSE. It ensures that users' plaintext data and keywords cannot be revealed by any unauthorized parties, and an adversary cannot learn any useful information about files and keywords through the proof index and update tokens used in %\name.
    %In our scheme, data privacy and keyword privacy is guaranteed by its underlying cipher. Moreover, the search pattern of our scheme is hiding by trading the space.
    \item \textbf{Verifiability:} A verifiable SSE scheme should be able to verify the freshness and integrity of the search results for users.
    %In our scheme, we design a proof algorithm based on the proof structure to detect the dara integrity attacks and meanwhile use the chained-timestamp mechanism to detect the replay attacks.
    \item \textbf{Efficiency:} A verifiable SSE scheme should achieve sublinear computational complexity, e.g. logarithmic $O(log(|W|))$, where $|W|$ is the number of keywords, even with file update. Note that, the computational complexity only refers to the cost of searching operations for verification, which does not include the complexity of the searching operations in the existing SSE schemes.
    %Update efficiency, search efficiency and verification efficiency is the most improtant indicator we aim to achieve. In our scheme, we leverage the Mekle Patricia Tree (MPT) which provides the $O(log(n))$ efficiency for search and update which is the optimal solution to the best of our knowledge.
  \end{enumerate}

  This paper aims to provide result verification for any SSE schemes, including but not limited to~\cite{stefanov2014practical,cash2014dynamic,kamara2012dynamic}. Therefore, we treat an existing SSE scheme as a black box such that our proposed scheme can be applied to these SSE schemes for result verification.
